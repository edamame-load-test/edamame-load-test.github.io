"use strict";(self.webpackChunkedamame_load_test_github_io=self.webpackChunkedamame_load_test_github_io||[]).push([[120],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(a),p=i,m=u["".concat(l,".").concat(p)]||u[p]||h[p]||s;return a?n.createElement(m,o(o({ref:t},c),{},{components:a})):n.createElement(m,o({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var d=2;d<s;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},2735:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const s=a.p+"assets/images/logo-light-green-63d3612d3b6478f963f4f702cf93876b.png",o={},r="Case Study",l={unversionedId:"case-study",id:"case-study",title:"Case Study",description:"1. Abstract",source:"@site/docs/case-study.md",sourceDirName:".",slug:"/case-study",permalink:"/docs/case-study",draft:!1,tags:[],version:"current",frontMatter:{}},d={},c=[{value:"1. Abstract",id:"1-abstract",level:2},{value:"2. Background: load testing",id:"2-background-load-testing",level:2},{value:"a. What is load testing?",id:"a-what-is-load-testing",level:3},{value:"b. Considerations when building a load tester",id:"b-considerations-when-building-a-load-tester",level:3},{value:"i. Client-side metrics",id:"i-client-side-metrics",level:4},{value:"ii. Scale",id:"ii-scale",level:4},{value:"iii. Testing environment",id:"iii-testing-environment",level:4},{value:"c. Summary",id:"c-summary",level:3},{value:"3. Background: Real-time collaboration apps",id:"3-background-real-time-collaboration-apps",level:2},{value:"a. What are real-time collaboration apps?",id:"a-what-are-real-time-collaboration-apps",level:3},{value:"b. Considerations when developing a collaboration app",id:"b-considerations-when-developing-a-collaboration-app",level:3},{value:"i. WebSocket performance",id:"i-websocket-performance",level:4},{value:"ii. Supporting separate protocols",id:"ii-supporting-separate-protocols",level:4},{value:"iii. Fan-out messaging pattern",id:"iii-fan-out-messaging-pattern",level:4},{value:"c. Summary",id:"c-summary-1",level:3},{value:"4. Load testing for collaboration apps",id:"4-load-testing-for-collaboration-apps",level:2},{value:"a. Generating HTTP and WebSocket traffic",id:"a-generating-http-and-websocket-traffic",level:3},{value:"b. Scaling to 200K concurrent users",id:"b-scaling-to-200k-concurrent-users",level:3},{value:"c. Collecting and displaying data in near real-time",id:"c-collecting-and-displaying-data-in-near-real-time",level:3},{value:"5. Existing solutions",id:"5-existing-solutions",level:2},{value:"a. DIY",id:"a-diy",level:3},{value:"b. Cloud-based services",id:"b-cloud-based-services",level:3},{value:"c. An in-between",id:"c-an-in-between",level:3},{value:"6. Edamame architecture",id:"6-edamame-architecture",level:2},{value:"7. Building Edamame",id:"7-building-edamame",level:2},{value:"a. Generating HTTP and WebSocket traffic",id:"a-generating-http-and-websocket-traffic-1",level:3},{value:"i. Choosing a load testing tool",id:"i-choosing-a-load-testing-tool",level:4},{value:"ii. Providing additional WebSocket metrics",id:"ii-providing-additional-websocket-metrics",level:4},{value:"b. Scaling to 200K concurrent users",id:"b-scaling-to-200k-concurrent-users-1",level:3},{value:"i. Choosing a container orchestration tool",id:"i-choosing-a-container-orchestration-tool",level:4},{value:"ii. Load generator synchronization",id:"ii-load-generator-synchronization",level:4},{value:"iii. Managing compute resources for load generators",id:"iii-managing-compute-resources-for-load-generators",level:4},{value:"c. Collecting and displaying data in near real-time",id:"c-collecting-and-displaying-data-in-near-real-time-1",level:3},{value:"i. Stream processing",id:"i-stream-processing",level:4},{value:"ii. Persisting data",id:"ii-persisting-data",level:4},{value:"iii. Visualizing results in near real-time",id:"iii-visualizing-results-in-near-real-time",level:4},{value:"8. Future plans",id:"8-future-plans",level:2}],u={toc:c},h="wrapper";function p(e){let{components:t,...a}=e;return(0,i.kt)(h,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"case-study"},"Case Study"),(0,i.kt)("h2",{id:"1-abstract"},"1. Abstract"),(0,i.kt)("p",null,"Edamame is a distributed load testing framework for testing messaging applications and collaboration tools that use both HTTP and WebSocket services. It is built for medium-sized companies that need to support up to 200k concurrently connected users. Edamame collects client-side metrics and displays data in near real-time, which provides developers deep insight into their systems. The ability to dynamically start and stop tests makes Edamame safe to run in either a staging or production environment."),(0,i.kt)("p",null,"Creating a load tester with these features comes with a unique set of challenges. First, the load tester needs to test the target system with multiple protocols in tandem and ensure that the concerns of different protocols are thoroughly addressed. Second, the kind of traffic medium-sized companies need to simulate requires a distributed architecture, which adds significant complexity to the tool. Third, providing client-side metrics in near real-time means systems need to be in place to collect, process, store, and visualize data in a performant way."),(0,i.kt)("p",null,"Edamame provided an open-source, easy-to-use, plug-and-play solution to the above challenges."),(0,i.kt)("h2",{id:"2-background-load-testing"},"2. Background: load testing"),(0,i.kt)("h3",{id:"a-what-is-load-testing"},"a. What is load testing?"),(0,i.kt)("p",null,"What happens when a web application gets more traffic than anticipated? Can the underlying infrastructure handle the traffic? Does the application slow down? Or\u2014worst case scenario\u2014does the application crash?"),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:"https://preview.redd.it/adi71n2nzl0a1.jpg?width=960&crop=smart&auto=webp&v=enabled&s=43a31699ab3508f3eb31d20b6bd8c32c6ecbfb41",alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0f Tweet or screenshot of Ticketmaster going down")),(0,i.kt)("p",null,"Overwhelming traffic is a frustrating reality for many internet users. Whether it's a popular online sale event like Black Friday or a highly anticipated concert, the surge of visitors to a website can cause it to slow down or even crash. Ticketmaster found out just how bad things could get when 14 million users trying to buy Taylor Swift tickets ",(0,i.kt)("a",{parentName:"p",href:"https://www.businessinsider.com/ticketmaster-14-million-people-tried-buy-taylor-swift-presale-tickets-2022-11"},"crashed their site"),"."),(0,i.kt)("p",null,"Developers, to ensure their application can handle this kind of situation, re-create high-traffic scenarios by performing load tests. ",(0,i.kt)("strong",{parentName:"p"},"Load testing"),' is the process of simulating user load on a system and measuring how that system responds. In a load test, a set number of programmatically generated "virtual users" are automated to interact with the system in pre-defined ways. This process helps developers identify performance bottlenecks within a system and provides assurance that the system can maintain expected standards, even under heavy strain.'),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fDepiction of a simple load test")),(0,i.kt)("p",null,"For a web application, one way to perform a basic load test is to use an HTTP benchmarking tool, like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/wg/wrk"},"wg/wrk"),". This involves sending frequent HTTP requests to a target endpoint in order to simulate bursty traffic, and seeing how that system responds."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="wrk command"',title:'"wrk','command"':!0},"wrk --connections=400 --duration=30s http://127.0.0.1:8080/index.html\n")),(0,i.kt)("p",null,"Despite the simplicity of this approach, load testing can have many levels of complexity. Depending on the developer's requirements, this can take many forms."),(0,i.kt)("h3",{id:"b-considerations-when-building-a-load-tester"},"b. Considerations when building a load tester"),(0,i.kt)("h4",{id:"i-client-side-metrics"},"i. Client-side metrics"),(0,i.kt)("p",null,"The first thing we need to consider is what metrics are we collecting."),(0,i.kt)("p",null,"Some load tests are more focused on server-side metrics, which include measurements like CPU usage and memory consumption for the target system. This informs a developer on the health of their system's server. In cases where server-side metrics are primary, these measurements are often obtained by system monitoring tools outside the load tester's purview."),(0,i.kt)("p",null,"A developer also needs to understand how the end user's experience may change under heavy load, which is where client-side metrics come in. These provide important insight by measuring things like HTTP response time, which tells us the overall latency of the target system. Other important measurements include the number of failed HTTP requests. An increase in numbers for either of these could indicate that the system is starting to regress."),(0,i.kt)("p",null,"Next, we must determine how these measurements are analyzed. One option is to view a tabular summary. This makes results easy to parse and gives a high-level overview of how the system responded.  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="wrk summary"',title:'"wrk','summary"':!0},"Running 30s test @ http://127.0.0.1:8080/index.html\n12 threads and 400 connections\nThread Stats   Avg      Stdev     Max   +/- Stdev\n  Latency   635.91us    0.89ms  12.92ms   93.69%\n  Req/Sec    56.20k     8.07k   62.00k    86.54%\n22464657 requests in 30.00s, 17.76GB read\nRequests/sec: 748868.53\nTransfer/sec:    606.33MB\n")),(0,i.kt)("p",null,"However, there are drawbacks associated with this approach, namely, it lacks granularity. The alternative is to plot individual data points along a time axis. This way, data is detailed enough to understand exactly when problems start to arise and we can also analyze causal relationships between different data points."),(0,i.kt)("p",null,'That being said, this approach has challenges of its own. Data generated from load testing tends to be very "noisy", that is, it lacks consistency and reliability making it difficult to discern a trend. To do so, we can perform data smoothing, which would typically involve taking some kind of average at time intervals. However, when performing load tests data points tend to differ by orders of magnitude, for example, we might see a response time of 100ms as well as 10s. Because of this disparity, taking an average skews results.'),(0,i.kt)("p",null,"Instead, it's more effective to find the 50th percentile, also known as the median. If your median is 200ms, now you know that 50% of response times were less than 200ms, and 50% were more. Looking at the tail end (>90%) of percentiles allows developers to understand the experience the majority of users have. For example, if the 99th percentile of response times is 200ms, it means that 99% of users have response times equal to or less than 200ms. In the context of load testing, therefore, looking at higher percentiles (90th, 95th, 99th) tends to be more telling than the median."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:"https://loadium.com/wp-content/uploads/2021/01/f1-1-1200x601.png",alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fVisualizing 99% percentiles")),(0,i.kt)("p",null,"Another consideration is how long the developer has to wait until they see data. A summary presupposes that there is no more data to process; the test is complete. For a short test (say 30 secs), this may not be an issue, however, load tests can be very long (say 3 hours). In this case, developers have to wait until the end of the test to view the results. Instead of waiting through the duration of the test, load testers can output granular data in near real time."),(0,i.kt)("p",null,"Near real-time data output can be very useful because it allows developers to respond to developments in test results as they occur. For example, being able to stop a test once a certain threshold is reached. However, near real-time processing is an engineering challenge, and may not be worth the additional complexity involved based on developer needs."),(0,i.kt)("h4",{id:"ii-scale"},"ii. Scale"),(0,i.kt)("p",null,"Running load tests locally is limiting. It's difficult to simulate thousands of separate users on a single host. Even using a load testing tool with a fairly low memory footprint, a 2-core CPU host with 8GB of RAM can generate a maximum of about ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/grafana/k6-benchmarks/tree/master/results/v0.42.0#ec2-m5large"},"6k virtual users"),"."),(0,i.kt)("p",null,"There are three main limiting factors to local load testing:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CPU"),": The CPU is heavily utilized in a load test. If it is not powerful enough, it can become a bottleneck, slowing down the test and limiting the number of virtual users that can be simulated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Memory"),": Load tests running on a single host cannot generate more virtual users than the RAM will support. Load tests often use 1 - 20 MB per virtual user, so even with only 1000 VUs, you might need up to 20GB of RAM to run that load test."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Network"),": If the network throughput is too low, the load test may not accurately simulate the real-world conditions of user traffic, resulting in inaccurate or unreliable test results. For instance, in our example host above the network bandwidth is ",(0,i.kt)("a",{parentName:"li",href:"https://aws.amazon.com/ec2/instance-types/m5/"},"up to 10GB"),".")),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:"https://k6.io/blog/static/f6d6d11d1540298928886d94d481824f/06b13/1_-_li-load-testing-overview.png",alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fDepiction of a distributed load test")),(0,i.kt)("p",null,"If local resources do not allow a developer to reach the desired number of virtual users, then it's necessary to run a distributed load test. In a ",(0,i.kt)("strong",{parentName:"p"},"distributed load test"),', multiple hosts generate load. The hosts which create virtual users and run the test are often known as "load generator nodes" or "test runner nodes". These can be horizontally scaled to support the number of virtual users required.'),(0,i.kt)("h4",{id:"iii-testing-environment"},"iii. Testing environment"),(0,i.kt)("p",null,"Another consideration is which environment we target in our load tests. Developers often use staging environments to mirror production environments. This provides a level of isolation that enables load tests to be conducted without fear of taking down any critical production services."),(0,i.kt)("p",null,"That being said, we may still want to run load tests in a production environment because this yields the most accurate results. Moreover, some companies (such as fast-growth startups) may not have the time or financial resources to implement a full duplicate staging environment. Finally, there might be overlapping resources between both staging and production. In this case, staging environments are not perfectly isolated, and care needs to be taken to prevent consequences to real end users."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fDepiction of staging and production potentially having overlapping resources")),(0,i.kt)("p",null,"Therefore if there is a risk to critical parts of the production environment, safeguards need to be put in place to protect the availability of production systems when running a load test."),(0,i.kt)("h3",{id:"c-summary"},"c. Summary"),(0,i.kt)("p",null,"Depending on developer needs, load testing can take many different forms. On the most basic level, we need to consider the data being collected, the required scale of the load test, and the environment being targeted."),(0,i.kt)("p",null,"Depending on an application's capability and complexity, more factors come into play. For example, messaging applications and collaboration tools have specific characteristics that need to be considered when determining what load testing approach should be taken."),(0,i.kt)("p",null,"In the next section, we take a look at how collaboration apps work and how these pose specific challenges that need to be answered by an effective load testing tool."),(0,i.kt)("h2",{id:"3-background-real-time-collaboration-apps"},"3. Background: Real-time collaboration apps"),(0,i.kt)("h3",{id:"a-what-are-real-time-collaboration-apps"},"a. What are real-time collaboration apps?"),(0,i.kt)("p",null,"Collaboration apps are applications that include some kind of real-time communication aspect."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Messaging"),": Slack, Discord, or Mattermost allow users to join rooms or channels and talk to each other in real-time."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Whiteboarding"),": Miro and Whimsical give teams a visual platform to collaborate on brainstorming aids and graphic deliverables like mind maps or flow charts."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Productivity"),": Coda is a versatile tool that enables teams to perform project management by collaborating on a series of documents, tables, and tasks.")),(0,i.kt)("p",null,"All of these tools benefit from ",(0,i.kt)("a",{parentName:"p",href:"https://ably.com/blog/what-it-takes-to-build-a-realtime-chat-or-messaging-app"},"low-latency data transfer")," (~100ms) and the ability for a server to push data directly to a client without relying on a request. To achieve these goals, the above collaboration apps rely on WebSockets."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fDepiction of the difference between HTTP and WS")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"WebSocket")," is a protocol that operates over HTTP and uses the underlying TCP layer to create a persistent connection between client and server. It allows for bi-directional communication between the client and server, unlike HTTP, in which a client must first initiate communication with a server by issuing a request. This persistent connection provided by WebSockets allows the server to stream events back to a client in real time."),(0,i.kt)("p",null,"On the client side, a WebSocket object is required in the browser to facilitate this persistent connection. The WebSocket object uses event-based asynchronous callbacks to handle incoming messages from the server, and can also send messages to the server. WebSocket messages, unlike HTTP, don't require a response."),(0,i.kt)("p",null,"On the server side, to connect with clients, a separate WebSockets server must be added to the architecture. Now we have traffic existing in two separate places; the WS server and the HTTP server."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fDepiction of more complex system including traffic split over two protocols")),(0,i.kt)("h3",{id:"b-considerations-when-developing-a-collaboration-app"},"b. Considerations when developing a collaboration app"),(0,i.kt)("h4",{id:"i-websocket-performance"},"i. WebSocket performance"),(0,i.kt)("p",null,'WebSocket is an entirely different protocol from HTTP. As a result, performance is measured and tracked differently. With HTTP, we are focused on the request-response cycle, so metrics like latency for HTTP responses based on differing levels of traffic are paramount. However, for WebSockets, as no response is required, messages can be considered "fire and forget". In this case, we\'re more concerned about the persistent connection, for example, how many connections have been dropped vs. how many connections are currently being maintained.'),(0,i.kt)("h4",{id:"ii-supporting-separate-protocols"},"ii. Supporting separate protocols"),(0,i.kt)("p",null,"Needing to support two entirely different protocols introduces significant complexity to the system. For example, HTTP and WebSocket servers could have different scaling needs. To determine the scalability thresholds of each, load tests would need to be run that address both traffic patterns."),(0,i.kt)("p",null,'WebSocket clients often exhibit different behavior from those that are connected via HTTP. When an HTTP server fails, traffic can be load balanced and re-directed to a replica the next time a request is issued. However, if a WebSocket server fails, all clients are disconnected from that bi-directional communication simultaneously. Often, they all try to reconnect at the same time, which can create a "thundering herds" problem. Applications that support both HTTP and WebSockets need to be able to handle this.'),(0,i.kt)("h4",{id:"iii-fan-out-messaging-pattern"},"iii. Fan-out messaging pattern"),(0,i.kt)("p",null,"Fan-out messaging pattern utilizes a one-to-many arrangement to emit messages, which enables a collaboration app to distribute messages to all users connected to the same channel in real-time. A message could be a literal chat message, a user's mouse movements, entering text into a shared document, drawing something on a whiteboard, or any other sort of data that needs to be propagated back up to collaborators."),(0,i.kt)("p",null,"For the aforementioned apps, the message being published can take the form of either an HTTP request or WebSocket message from the client. To enable real-time communication, messages are sent back up to subscribed collaborators vis WebSocket. Depending on how large the channel is, one published message can lead to a sizeable fan-out."),(0,i.kt)("p",null,"For example, if you send a message to a Slack channel with 1k subscribers, the single POST request that sends the message turns into 1k WebSocket messages being emitted."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fFanout")),(0,i.kt)("h3",{id:"c-summary-1"},"c. Summary"),(0,i.kt)("p",null,"Managing a real-time collaboration app poses a unique set of circumstances that developers must take into consideration. WebSocket servers and clients behave differently than their HTTP counterparts, and so additional scenarios like WebSocket performance, thundering herds, and fan-out messaging must be accounted for. To ensure this, developers perform load tests that accurately mimic these kinds of behaviors."),(0,i.kt)("h2",{id:"4-load-testing-for-collaboration-apps"},"4. Load testing for collaboration apps"),(0,i.kt)("p",null,"Due to the rise of remote work, applications in this space can grow very quickly. For example, ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/miro-engineering/reliable-load-testing-with-regards-to-unexpected-nuances-6f38c82196a5"},"Miro grew from 12k to 100k concurrently connected users")," in the space of a year. Fast growth requires scalability, which can compound the challenges listed above. To understand how such a system responds to stress and see if it remains operational amidst an influx of connections, load tests should have a certain set of characteristics to be effective."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It needs to ensure that all architecture components supporting both HTTP and WebSocket are sufficiently tested. This means that the virtual users should be able to mimic both an HTTP and WebSocket client."),(0,i.kt)("li",{parentName:"ul"},"It should be able to generate up to 200k virtual users per test to support the needs of medium-to-large collaboration apps."),(0,i.kt)("li",{parentName:"ul"},"It should be able to collect and display granular data pertaining to both HTTP and WebSocket concerns. To ensure the safety of target systems in an agnostic environment, this data should be emitted in near real-time.")),(0,i.kt)("h3",{id:"a-generating-http-and-websocket-traffic"},"a. Generating HTTP and WebSocket traffic"),(0,i.kt)("p",null,"Typically, the HTTP server and WS server need to be tested in tandem to get an accurate picture of how the system responds to load. For applications that only support HTTP endpoints, an HTTP load tester is sufficient. However, collaboration apps cannot rely on HTTP requests alone for load testing, as client traffic is divided between two different protocols. HTTP-focused load tests do not cover all components of a collaborative application's architecture."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fAn image that shows how a traditional API blaster only tests part of the system / re-working of the first koi pond diagram. ")),(0,i.kt)("p",null,"In an HTTP load test, requests are sent to the HTTP server. This causes data to be sent to the WebSocket server in response, so that the messages received can be propagated to subscribed users. However, if the virtual users in the load test do not maintain persistent WebSocket connections, the WebSocket server never has to emit any messages (there are no active subscribers). This means that a critical part of the architecture never has to sustain any load."),(0,i.kt)("p",null,"Due to fan-out messaging, the number of WebSocket messages that must be sent (and therefore, the amount of load the WebSocket server must sustain) can be orders of magnitude different from the amount of HTTP requests being received. It is of vital importance that the virtual users in the load test accurately simulate the persistently connected WebSocket clients."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fAn image that shows how a system can be tested holistically, with persistently connected clients to show how it ")),(0,i.kt)("p",null,"This limits the choice of load testing tools to those that support both HTTP and WebSockets. The load tester should also collect meaningful metrics pertaining to both protocols, which may or may not be included."),(0,i.kt)("h3",{id:"b-scaling-to-200k-concurrent-users"},"b. Scaling to 200K concurrent users"),(0,i.kt)("p",null,"During their Series A stage, Miro grew from 12k to 100k currently connected users in the space of a year. Typically, a company in the Series A stage wants to see growth like this; their goal is to be rapidly and predictably scaling, and to ensure that their supporting infrastructure is scaling in tandem with the number of users."),(0,i.kt)("p",null,"While the actual numbers of daily active users varies from company to company, our research shows that late stage Series A companies are typically around the 100k range. An effective load tester for a company in this phase of growth should allow tests of up to 100% this number, which we estimate to be about 200k virtual users."),(0,i.kt)("p",null,"Running load tests that generate 200k virtual users necessitates a distributed architecture, due to the amount of compute resources required. In most cases, this means moving to the cloud. This requires a number of different cloud-based components, meaning we need a system to manage the required infrastructure."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fVisualizing why syncing nodes is important")),(0,i.kt)("p",null,"One major concern with distributed load tests is how to synchronize the load generators. Load tests often have a predefined pattern for how the number of virtual users is ramped up and down over the duration of the test. Different patterns test how systems respond to different scenarios."),(0,i.kt)("p",null,"For example, a load test may ramp up from zero to 100k VUs over the course of a five minute interval, and then immediately start ramping back down to zero VUs over the next five minutes. If this test is spread across five nodes, then all five nodes must start the test at exactly the same time. Otherwise, the test will never reach 100k VUs at its peak."),(0,i.kt)("p",null,"Therefore, we need a way to synchronize load generator nodes to ensure they all start ramping up the load at the same time, and stay in line with each other to match the predefined pattern of load."),(0,i.kt)("p",null,"Providing a way to manage load generator nodes also gives the load tester the ability to stop the test, in case critical aspects of a production environment are threatened by the additional load."),(0,i.kt)("h3",{id:"c-collecting-and-displaying-data-in-near-real-time"},"c. Collecting and displaying data in near real-time"),(0,i.kt)("p",null,"Fast-growth companies may not have time to set up isolated staging environments to perform tests (growth could happen overnight). A load testing tool can take the dangers associated with this into consideration by providing near real-time results. If systems begin to show signs of degrading, the test can be stopped immediately."),(0,i.kt)("p",null,"To facilitate near real-time visualization of data, the load tester requires a stream processing approach as opposed to batch processing. Batch processing presupposes the data has a defined start and finish, meaning that batch processing delivers results like end-of-test summaries. This is a time consuming approach that does not suit the time-sensitive nature of load test data for tests targeting an agnostic environment."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:"https://hazelcast.com/wp-content/uploads/2021/12/diagram-stream-processing.png",alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fGraphic showing simple stream processing system")),(0,i.kt)("p",null,'Stream processing, on the other hand, assumes data is unbound and arrives continually over time. To derive analytics like percentiles from the data stream, the system splits data up into time intervals. All the data points that fit into one of these "windows" is aggregated and sent to storage. This comes with challenges of its own.'),(0,i.kt)("p",null,"More virtual users means more data. The amount of data depends on a variety of factors, including the type of load test, which load testing tool is used to conduct the test, which metrics are being collected, and how frequently they are being collected. For example, a test in which virtual users are making HTTP requests each second would result in a higher amount of data than a test in which a request is made every ten seconds. Stream processing data in vast quantities could be difficult."),(0,i.kt)("p",null,"Finally, we need a storage method and an effective visualization tool that can show all this data in an understandable way. The visualization tool can then continually pull from storage as data is added, allowing developers to see analyzed data as the test executes."),(0,i.kt)("h2",{id:"5-existing-solutions"},"5. Existing solutions"),(0,i.kt)("p",null,"There are many existing solutions for load testing tools in general, for example, k6, Locust, JMeter, and Artillery, to name a few. While all these companies offer open-source load testers, they are typically meant for local use, meaning resources for producing high numbers of virtual users are limited to one host. However, our specifications require supporting up to 200k users per test, which necessitates a distributed architecture."),(0,i.kt)("p",null,"It is possible to use an open source tool in a distributed manner, but it involves managing all the necessary cloud infrastructure yourself. For example, ",(0,i.kt)("a",{parentName:"p",href:"https://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html"},"JMeter offers a guide")," and controller construct to help users run distributed tests. If a company has very specific needs, they may even consider developing their own internal load testing tool rather than extending the capabilities of an open-source tool by distributing the test."),(0,i.kt)("p",null,"This approach, however, involves significant complexity. Many open-source load testing tools offer a managed cloud service which abstracts away all the challenges of distribution. While this is a convenient option, it does come with limitations such as data ownership and cost."),(0,i.kt)("p",null,"Edamame aims to bridge the gap between open-source and paid cloud services by providing a load testing tool with built-in distribution management that's simple to deploy and run."),(0,i.kt)("h3",{id:"a-diy"},"a. DIY"),(0,i.kt)("p",null,"A number of real-world collaborative apps have taken a DIY approach to either develop a custom load testing tool or extend an existing open-source tool and manage the distribution."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:"https://slack.engineering/wp-content/uploads/sites/7/2021/04/Screen-Shot-2021-04-21-at-4.30.30-PM.png",alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fKoi Pond")),(0,i.kt)("p",null,"Slack built ",(0,i.kt)("a",{parentName:"p",href:"https://slack.engineering/load-testing-with-koi-pond/"},"Koi Pond"),", which is an internal tool that leverages a distributed Kubernetes architecture in order to ensure sufficient connected virtual users. Load is generated using a custom tool written in Go, and virtual user behavior is dictated by a JSON file. Koi Pond streams data which is displayed in a Grafana dashboard as a test runs."),(0,i.kt)("p",null,"Miro facilitates WebSocket load testing by extending JMeter with a plugin and custom scripts. To mitigate the costs associated with running load tests on AWS, they use temporary Spot instances which are only active for the duration of the test."),(0,i.kt)("p",null,"For developers looking to build their own custom distribution solution, ",(0,i.kt)("a",{parentName:"p",href:"https://aws.amazon.com/solutions/implementations/distributed-load-testing-on-aws/"},"AWS")," and ",(0,i.kt)("a",{parentName:"p",href:"https://cloud.google.com/architecture/distributed-load-testing-using-gke"},"Google Cloud")," both have guides on how to manage the underlying infrastructure to facilitate this.In this approach, the developer takes on all responsibility for the challenges associated with running a distributed test."),(0,i.kt)("h3",{id:"b-cloud-based-services"},"b. Cloud-based services"),(0,i.kt)("p",null,"If a developer does not wish to manage the complexity involved with a distributed load test, using a cloud-based solution abstracts away many of the challenges involved. Cloud based solutions are paid services that handle all underlying infrastructure for running tests, data collection, data processing, near real-time visualization, and data storage. This makes it very easy for developers to run large-scale load tests."),(0,i.kt)("p",null,"That being said, cloud-based solutions also have their trade-offs. They can be very costly. Moreover, because all data storage is managed, a user does not retain control over their own data. Different cloud-based solutions will place different limits on how long data is retained."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null," \ud83d\uddbc\ufe0fChart of Cloud-based tools")),(0,i.kt)("p",null,"Another issue is cloud-based solutions are not as flexible. For example, the k6 open-source load tester is quite extensible, which allows developers to customize which metrics their load tests are tracking by default. However, the ",(0,i.kt)("a",{parentName:"p",href:"https://k6.io/blog/extending-k6-with-xk6/"},"k6 cloud platform does not support utilizing these extensions"),", which compromises developer experience."),(0,i.kt)("h3",{id:"c-an-in-between"},"c. An in-between"),(0,i.kt)("p",null,"There are limited options when it comes to a distributed load testing solution that is both open-source and offers the many of the benefits a cloud-based service. ",(0,i.kt)("a",{parentName:"p",href:"https://www.artillery.io/docs/guides/guides/distributed-load-tests-on-aws-lambda"},"Artillery is one example of an open-source tool that allows for distributed load tests that are easy to deploy"),", but it comes with significant drawbacks. Tests are run using AWS Lambda (AWS's serverless function offering), which limits them to a 15 minute duration. Distributed load tests run using Artillery also cannot be stopped mid-test."),(0,i.kt)("p",null,"Edamame lives in the liminal space between a DIY and SaaS solution. It is open source and provides many of the benefits of a cloud-based service like managed distribution and near real-time data visualization. It also addresses the limitation of these services by giving users full control over their own data. It is built with collaboration apps in mind, and features meaningful metrics for both HTTP and WebSockets out of the box."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null,"\ud83d\uddbc\ufe0fA more high-level chart that compares Edamame and existing solutions")),(0,i.kt)("p",null,"Edamame is a specific tool built for a specific use case, so it has limitations as well. Applications that need to support levels of concurrency may not wish to utilize Edamame, as it does not support more than 200k virtual users per test. Edamame does not integrate into a CI/CD pipeline like GitHub Actions or Jenkins. Because Edamame targets collaborative apps, it does not support protocols outside HTTP and WebSockets."),(0,i.kt)("h2",{id:"6-edamame-architecture"},"6. Edamame architecture"),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null,"\ud83d\uddbc\ufe0fHigh level overview of architecture")),(0,i.kt)("p",null,"Edamame contains six main components:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A CLI and GUI provide interfaces the user to manage load tests. They communicate with the Edamame architecture which is deployed using AWS Elastic Kubernetes Service (EKS) in the user's AWS account."),(0,i.kt)("li",{parentName:"ol"},"The k6 operator receives test scripts from the user interface, and is responsible for initializing and synchronizing a distributed test."),(0,i.kt)("li",{parentName:"ol"},"Load generators are pods hosted in a dedicated node group. They run the test script and simulate the virtual users needed to conduct the test."),(0,i.kt)("li",{parentName:"ol"},"Statsite receives and aggregates data being streamed using StatsD protocol from the load generators."),(0,i.kt)("li",{parentName:"ol"},"The PostgreSQL database stores data that is output from Statsite."),(0,i.kt)("li",{parentName:"ol"},"Grafana pulls data from the database and displays it in near real-time using a custom dashboard specifically designed for visibility of HTTP and WebSockets metrics.")),(0,i.kt)("h2",{id:"7-building-edamame"},"7. Building Edamame"),(0,i.kt)("p",null,"In building Edamame our goal was to provide a tool that met all the specifications in ",(0,i.kt)("a",{parentName:"p",href:"#4-load-testing-for-collaboration-apps"},"4. Load testing for collaboration apps"),". In brief, these were:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Generating HTTP and WebSocket traffic"),(0,i.kt)("li",{parentName:"ul"},"Scaling up to 200k concurrent users"),(0,i.kt)("li",{parentName:"ul"},"Collecting and displaying data in near real-time")),(0,i.kt)("h3",{id:"a-generating-http-and-websocket-traffic-1"},"a. Generating HTTP and WebSocket traffic"),(0,i.kt)("h4",{id:"i-choosing-a-load-testing-tool"},"i. Choosing a load testing tool"),(0,i.kt)("p",null,"There are many open-source tools for load testing we can build upon to ensure Edamame load tests generate both HTTP and WebSocket traffic. There are a number of factors that should be considered when selecting one, including performance, usability, and level of WebSocket support."),(0,i.kt)("p",null,"Performance considerations include things like requests per second and memory usage. Requests per second (or RPS) measures how much traffic a load testing tool is generating. Higher RPS means a more performant load generator, as it represents CPU efficiency; a higher RPS means less CPU is utilized per request. Memory usage is also a concern when trying to determine how scalable a load testing tool is, as large numbers of virtual users can be very demanding on RAM. Because Edamame needs to support such a high number of virtual users, we need a tool that requires minimal amount of RAM per VU."),(0,i.kt)("p",null,"Ease of use is also an important consideration. For example, how does the user define the tests themselves? Using a scriptable tool allows developers to write detailed and flexible scenarios that virtual users will perform. Depending on the tool, these can be defined via either a general purpose programming language or a DSL. Non-scriptable tools do not provide this kind of customization and flexibility, however."),(0,i.kt)("p",null,"Finally, the level of support for WebSockets varies from tool to tool. Some tools feature native support for WebSockets, other require third party plug ins, and some do not enable virtual users that simulate WebSocket clients at all."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Tool"),(0,i.kt)("th",{parentName:"tr",align:null},"wrk"),(0,i.kt)("th",{parentName:"tr",align:null},"Gatling"),(0,i.kt)("th",{parentName:"tr",align:null},"Artillery"),(0,i.kt)("th",{parentName:"tr",align:null},"K6"),(0,i.kt)("th",{parentName:"tr",align:null},"JMeter"),(0,i.kt)("th",{parentName:"tr",align:null},"Locust"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Written in"),(0,i.kt)("td",{parentName:"tr",align:null},"C"),(0,i.kt)("td",{parentName:"tr",align:null},"Scala"),(0,i.kt)("td",{parentName:"tr",align:null},"NodeJS"),(0,i.kt)("td",{parentName:"tr",align:null},"Go"),(0,i.kt)("td",{parentName:"tr",align:null},"Java"),(0,i.kt)("td",{parentName:"tr",align:null},"Python")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Scriptable"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: Lua"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: Scala"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: JS"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: JS"),(0,i.kt)("td",{parentName:"tr",align:null},"Limited: XML"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: Python")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Managed distributed load generation"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Limited"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"No")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Max requests per second (RPS)"),(0,i.kt)("td",{parentName:"tr",align:null},"54100"),(0,i.kt)("td",{parentName:"tr",align:null},"4700"),(0,i.kt)("td",{parentName:"tr",align:null},"321"),(0,i.kt)("td",{parentName:"tr",align:null},"11300"),(0,i.kt)("td",{parentName:"tr",align:null},"7000"),(0,i.kt)("td",{parentName:"tr",align:null},"2900")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Mem Usage per 1VU MB*"),(0,i.kt)("td",{parentName:"tr",align:null},"0.25"),(0,i.kt)("td",{parentName:"tr",align:null},"11.85"),(0,i.kt)("td",{parentName:"tr",align:null},"6.31"),(0,i.kt)("td",{parentName:"tr",align:null},"2.22"),(0,i.kt)("td",{parentName:"tr",align:null},"20.17"),(0,i.kt)("td",{parentName:"tr",align:null},"7.16")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"WS Support"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: Native"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: Native"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: Native"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: 3rd party"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes: 3rd party")))),(0,i.kt)("p",null,"Edamame utilizes and extends k6 for it's load testing framework. We chose k6 because it's one of the most lightweight load-testing tools in terms of how much memory is required per VU which makes it highly scalable. Furthermore, users can provide test scripts written in JavaScript, which is a well known general purpose programming language. It has native support for WebSockets, so it can be used to test both HTTP and WebSocket servers."),(0,i.kt)("h4",{id:"ii-providing-additional-websocket-metrics"},"ii. Providing additional WebSocket metrics"),(0,i.kt)("p",null,"While k6 provides many benefits, the default metrics for WebSockets have limitations in that they do not tell the full story of how the targeted WebSocket server is performing. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"ws_session_duration")," is determined by the user's test script and does not have a high correlation with WebSocket server performance."),(0,i.kt)("div",{class:"text--center"},(0,i.kt)("img",{src:s,alt:"Example banner",width:"400"}),(0,i.kt)("p",null,"\ud83d\uddbc\ufe0fShow where the custom extension goes and how the binary is compiled")),(0,i.kt)("p",null,"Due to the extensibility of k6, we were able to build a custom extension that tracks five additional metrics. This enables Edamame to provide better visibility into WebSocket performance."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Metric"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ws_current_connections")),(0,i.kt)("td",{parentName:"tr",align:null},"The current number of active WebSocket connections. This is important because the k6 default metrics only provide the total number of connections, rather than how many connections are being persisted at any given time.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ws_failed_handshakes")),(0,i.kt)("td",{parentName:"tr",align:null},"The number of WebSocket connections that could not be established. An increase of these failures could indicate performance issues with the target system.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ws_abnormal_closure_error")),(0,i.kt)("td",{parentName:"tr",align:null},"The number of connections that are dropped, measured by counting the number of 1006 abnormal closure error messages.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ws_msgs_bytes_sent")),(0,i.kt)("td",{parentName:"tr",align:null},"The total number of bytes sent in WebSocket messages. As the size of messages can vary widely, this provides additional context to the default k6 ",(0,i.kt)("inlineCode",{parentName:"td"},"ws_msgs_sent")," metric.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ws_msgs_bytes_received")),(0,i.kt)("td",{parentName:"tr",align:null},"The total number of bytes received in WebSocket messages.")))),(0,i.kt)("h3",{id:"b-scaling-to-200k-concurrent-users-1"},"b. Scaling to 200K concurrent users"),(0,i.kt)("h4",{id:"i-choosing-a-container-orchestration-tool"},"i. Choosing a container orchestration tool"),(0,i.kt)("h4",{id:"ii-load-generator-synchronization"},"ii. Load generator synchronization"),(0,i.kt)("h4",{id:"iii-managing-compute-resources-for-load-generators"},"iii. Managing compute resources for load generators"),(0,i.kt)("h3",{id:"c-collecting-and-displaying-data-in-near-real-time-1"},"c. Collecting and displaying data in near real-time"),(0,i.kt)("h4",{id:"i-stream-processing"},"i. Stream processing"),(0,i.kt)("h4",{id:"ii-persisting-data"},"ii. Persisting data"),(0,i.kt)("h4",{id:"iii-visualizing-results-in-near-real-time"},"iii. Visualizing results in near real-time"),(0,i.kt)("h2",{id:"8-future-plans"},"8. Future plans"))}p.isMDXComponent=!0}}]);